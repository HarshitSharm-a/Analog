%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 136 85
%%Creator: Cadence Design Systems
%%EndComments
%%BeginProlog
%%DocumentFonts:Courier
%******************************************************************************
%
% The preview image should preceed this file if a preview is being generated.
%
% This should be the first line: %!PS-Adobe-2.0 EPSF-1.2
% There should also be a BBox:   %%BoundingBox:0 0 300 300
%
% Cadence Design Systems -- Supports Both Level 1 and Level 2 Printers
%
% EPS Prologue -- Version 97B (aka 9702)
%
/setpacking where
{
	/currpack currentpacking def
	pop true setpacking
} if
%******************************************************************************
/gis  {
  0 setgray
  mark
  save
  newpath

  72 resolution div
  dup
  scale

  /stippleArray 10 array def
    stippleArray
     dup    0  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    1  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    2  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    3  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    4  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    5  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    6  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    7  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    8  <08080404020201018080404020201010
	        08080404020201018080404020201010> put
	    9  <08081414222241418080414122221414
		08081414222241418080414122221414> put



  /newFont 10 dict def
  newFont begin

    /FontType 3 def
    /FontMatrix [1 0 0 1 0 0] def
     /FontBBox [0 0 1 1] def

    /Encoding 256 array def
    0 1 255 {Encoding exch /.notdef put} for
    Encoding
      dup 48 /0  put
      dup 49 /1  put
      dup 50 /2  put
      dup 51 /3  put
      dup 52 /4  put
      dup 53 /5  put
      dup 54 /6  put
      dup 55 /7  put
      dup 56 /8  put
          57 /9  put

    /BuildChar {
        /char exch def
        /fontdict exch def
	/charname fontdict /Encoding get char get def

         1 0 setcharwidth

          16 16 true
          [16 0 0 -16 -.5 15.50]
           stippleArray char 48 sub 1 getinterval cvx
          imagemask
    } def

  end
  /StippleFont newFont definefont 66 scalefont setfont
  /fillChar 0 def

  /ellipsedict 8 dict def
  ellipsedict /mtrx matrix put

  /xformdict 6 dict def
  xformdict /xformmtrx matrix put

  /rt 0 def
  /color     0 def

  /lineRed   0 def
  /lineGreen 0 def
  /lineBlue  0 def

  /fillRed   0 def
  /fillGreen 0 def
  /fillBlue  0 def

  /hatchSet 0 def

  /rht 0 def
  /rw 0 def
  /ils 1.0 def
  /textalign 1 def

  gsave

  } def

/cdsLevel2 /languagelevel where {pop languagelevel} {1} ifelse 2 ge def

/cdsColor cdsLevel2 not {
                          false
                          /colorimage where {pop pop true} if
                        } {
	                  true
                        } ifelse
def

/gfs  {
    grestore
    showpage
    restore
    cleartomark
  } def
/pap {
    /resolution exch def
    /pageHeight exch def
    /pageWidth exch def

  } bind def
/rotp  {
  /rt 90 def
  grestore
} def
/clwin  {
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    rt 90 eq
      {
        pageWidth 0 translate
        rt rotate
	/rt 0 def
	gsave
      } if

    grestore
    gsave
    newpath
    x1 y1 moveto
    x2 y1 lineto
    x2 y2 lineto
    x1 y2 lineto
    closepath
    clip
    newpath
} def
/bblineto {
  dup dup   /cury exch def
  miny lt {/miny exch def}
    {dup maxy gt { /maxy exch def }
           {pop } ifelse } ifelse
  dup dup
  minx lt {/minx exch def}
    {dup maxx gt { /maxx exch def }
           { pop } ifelse } ifelse
  cury lineto
} def
/bbmoveto {
  dup dup
  /miny exch def /maxy exch def /cury exch def
  dup dup
  /minx exch def /maxx exch def
  cury moveto
} def
/ellipse
  { ellipsedict begin
    /endangle exch def
    /startangle exch def
    /yrad exch def
    /xrad exch def
    /y exch def
    /x exch def

    /savematrix mtrx currentmatrix def
    x y translate
    xrad yrad scale
    0 0 1 startangle endangle arc
    savematrix setmatrix
    end
  } def
/dls  {
  gsave
  newpath
  moveto
  rlineto
  setLineColor
  stroke
  grestore
} def
/dlt  {
  newpath
  gsave
  setLineColor
  moveto
} def
/dslt  {
  newpath
  gsave
  setLineColor
  moveto
} def
/dlv  {
  rlineto
} def
/dle  {
  stroke
  grestore
} def
/mps {
  newpath
  moveto
} def
/dbu  {
    setLineColor
    newpath
    moveto
    dup 0 rlineto
    0 3 -1 roll
    rlineto
    neg 0 rlineto
    closepath
    stroke
  } def
/dbf  {
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    gsave
      newpath
      x1 y1 bbmoveto
      x2 y1 bblineto
      x2 y2 bblineto
      x1 y2 bblineto
      closepath
      clip fillpath
    grestore
  } def

/dbs  {
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
      newpath
      x1 y1 moveto
      x2 y1 lineto
      x2 y2 lineto
      x1 y2 lineto
      closepath
      gsave
      setFillColor
      fill grestore
      setLineColor stroke

} def
/dpb { gsave
      newpath bbmoveto
} def
/dpu  {
        closepath
        setLineColor
        stroke
      grestore
} def
/dpf  {
       closepath
       clip fillpath
     grestore
} def
/dps  {
       closepath
       setFillColor
       fill grestore
       setLineColor stroke
} def
/dpv  {
    bblineto
} def
/dcu  {
    /radius exch def
    /y exch def
    /x exch def

    gsave
      newpath
      x y radius radius 0 360 ellipse
      setLineColor
      stroke
    grestore
} def
/dcf  {
    /radius exch def
    /y exch def
    /x exch def
    /minx x radius sub def
    /miny y radius sub def
    /maxx x radius add def
    /maxy y radius add def
    gsave
      newpath
      x y radius radius 0 360 ellipse
      clip fillpath
    grestore
  } def
/dcs  {
    /radius exch def
    /y exch def
    /x exch def

    gsave
      newpath
      x y radius radius 0 360 ellipse
      setFillColor
      fill
    grestore
    setLineColor stroke
  } def
/delu  {
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def

    newpath
      x y xradius yradius 0 360 ellipse
      gsave
      setFillColor
      stroke
    grestore
  } def
/delf  {
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def
    /minx x xradius sub def
    /miny y yradius sub def
    /maxx x xradius add def
    /maxy y yradius add def

    gsave
      newpath
      x y xradius yradius 0 360 ellipse
      clip fillpath
    grestore
  } def
/dels  {
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def

    gsave
      newpath
      x y xradius yradius 0 360 ellipse
      setFillColor fill
    grestore
    setLineColor stroke
} def
/dau  { gsave
          newpath ellipse
          setLineColor
          stroke
        grestore
} def
/setlinedash {
    1 index length 11 gt
    {exch dup length 11 sub 11 getinterval exch } if
    setdash
} def

/lpb    {
    pop
    [
    /offset 0 def
    /offcount 0 def
    /oncount 0 def
} def

/lpon  {
    /oncount exch def
    pop
    oncount
} def

/lpoff  {
    /offcount exch def
    pop
    oncount 0 eq
    {/offset offcount def }
    { offcount } ifelse
} def

/lpe  {
    /linewidth exch def
    pop
    offset 0 ne
    { offset } if ] 0 setlinedash
    linewidth setlinewidth
} def

/sls    { pop } def

/ssls  { [] 0 setdash
          1 setlinewidth
} def
/fillpath  {
    setFillColor
    /str 1 string def
    /minx minx 66 div
    truncate 66 mul def
    /miny miny 66 div
    truncate 66 mul def

          /fillLine maxx minx sub cvi 66 idiv 1 add string def

          0 1 fillLine length 1 sub {
            fillLine exch fillChar str cvs cvi 48 add put
          } for

          minx
          miny 66 maxy
            { exch dup 3 -1 roll moveto fillLine show
          } for pop
    hatchSet 1 eq {setLineColor stroke} if
} def

/fds  { pop /currchar 30 def} def
/fdf   {
    exch
    /char exch def
    /stipple stippleArray char get def
    stipple exch currchar
    exch putinterval
    stippleArray char stipple put
    /currchar currchar 2 sub def
  } def
/fde  {
    pop
  } def
/sfp  {
    /fillChar exch def
    /hatchSet 0 def
    fillChar 8 ge {/hatchSet 1 def} if
    /StippleFont findfont 66 scalefont setfont
  } def

  /setLineColor {
    cdsLevel2 cdsColor or {
      lineRed    1000 div
      lineGreen  1000 div
      lineBlue   1000 div
      setrgbcolor } if
  } def

  /setFillColor {
    cdsLevel2 cdsColor or {
      fillRed    1000 div
      fillGreen  1000 div
      fillBlue   1000 div
      setrgbcolor }
      { 0 setgray } ifelse
  } def

  /slc {
    /lineBlue  exch def
    /lineGreen exch def
    /lineRed   exch def
    /color 1 def
    lineBlue 1000 eq {lineGreen 1000 eq {lineRed 1000 eq {
      /lineBlue  0 def
      /lineGreen 0 def
      /lineRed   0 def
    } if} if} if
  } def

  /sfc {
    /fillBlue  exch def
    /fillGreen exch def
    /fillRed   exch def
    /color 1 def
    fillBlue 1000 eq {fillGreen 1000 eq {fillRed 1000 eq {
      /fillBlue  0 def
      /fillGreen 0 def
      /fillRed   0 def
    } if} if} if
  } def

%******************************************************************************
% Resident Font Scale Sequence
%    x y rfss
%
/rfss  {
    4 2 roll
    dup
    3 div
    add
    scalefont
    setfont
    0 color ne {setLineColor}
               { 0 setgray } ifelse
  } bind def
%******************************************************************************
% Resident Font End
%
%
/rfe
{
/width exch def
5 1 roll
moveto

xformdict begin
/savematrix xformmtrx currentmatrix def

exch 				% rotate mirror to mirror rotate
matrix rotate concat		% add rotation to current transform matrix
dup 1 eq
	{pop 1 -1}		% X mirror

	{2 eq
		{-1 1}		% Y mirror
		{1 1}		% No mirror
	ifelse}
ifelse matrix scale concat	% add mirror to current transform matrix


dup				% duplicate (string)
length				% replace one of the strings with its length
dup 0 ne
{
	3 -1 roll		% move fixed width flag to top of stack
	0 eq
	{			% if flag is false (0) do old string handling
		/numChr exch def
		dup stringwidth	%stack  wy,wx,(string)
		pop
		width
		exch sub	%stack  xdiff,ydiff,(string)

		cvi
		numChr idiv	%stack  xspace,ydiff,(string)

		/xoff exch def

		{		% this is the positioning  function for kshow
			pop pop
			xoff
			0
			rmoveto
		}

		exch
		kshow
	}

	{			% if flag is true (not 0) just show string
		pop show
	}
	ifelse
}

{
	pop pop pop
}
ifelse
      savematrix setmatrix
    end
  } bind def
%******************************************************************************
% Resident Font Text Alignment
%
/rfta {						% <align> rfta
	/textalign exch def
} bind def
%******************************************************************************
% Resident Font Interline Space
%
/rfis {						% <space> rfis
	/ils exch def
} bind def
%******************************************************************************
% Resident Font Scale
%
/rfsc {						% <ht> <rotate> <mirror> rfs
% What I need to do here is to validate <ht>.  <ht> can not be 0.  If it is 0
% then make it 1.  To do this I will need to use the roll operation and exch
% and maybe dup.  The algorithm looks like this:
% Roll stack to make it look like : <rotate> <mirror> <ht>
% duplicate <ht> so I can test it.
% If <ht> is equal to 0 then
% exchange 1 for <ht>
% In any case roll stack to make it look like: <ht> <rotate> <mirror>
% qed.
%
	3 -1 roll		% <rotate> <mirror> <ht>
	dup 0 eq
	{
		1 exch pop	% <rotate> <mirror> <ht=1>
	}
	if
	3 1 roll		% <ht> <rotate> <mirror>

	0 color ne
	{
		setLineColor
	}
	{
		0 setgray
	}
	ifelse

	/tasz 60 def
	/taln 59 def

	/ta tasz array def
	/cta ta def
	/tc 0 def
	/sa tasz array def
	/sc 0 def
} bind def
%******************************************************************************
% Resident Font Restricted Text
%
/rfrt {						% <height> <width> rfrt
	/rht exch def
	/rw exch def
	% Since restricting one dimension and not the other is not supported
	% if one dimension is turned off then ensure that both dimensions
	% are turned off (a value of 0 means no restriction)
	rht 0 eq rw 0 eq or
	{
		/rht 0 def
		/rw 0 def
	}
	if
} bind def
%******************************************************************************
% Resident Font Text Score
%
/rfts {						% <score> <start> <end> rfts
	sc tasz lt
	{
		3 -1 roll 3 array astore
		sa sc 3 -1 roll put
		/sc sc 1 add def
	}
	{
		pop pop pop
	} ifelse
} bind def
%******************************************************************************
% Resident Font Text
%
/rft {						% (text) rft
	tc taln gt tc tasz mod 0 eq and
	{
		cta /cta tasz array dup def put
	} if

	tc tasz mod exch cta 3 1 roll sc
	sa dup length array copy
	3 array astore put

	/sc 0 def
	/tc tc 1 add def
} bind def
%******************************************************************************
% Resident Font Complete
%
/rfc {						% <x> <y> rfc
	/cta ta def

	%
	% If text is restricted or if text alignment is not left, find the
	% longest text string
	%
	/mw 0 def
	rw 0 ne textalign 3 gt or
	{
		%
		% Find the widest text string
		%
		5 index		% <fn> <ht> <rot> <mir> <x> <y> <fn>
		setfont
		0 1 tc 1 sub
		{
			dup taln gt 1 index tasz mod 0 eq and
			{
				/cta cta tasz get def
			}
			if

			tasz mod cta exch get 0 get
			stringwidth pop dup mw gt
			{
				/mw exch def null
			}
			if

			pop
		}
		for

		/cta ta def
	}
	if

	%
	% Operand stack:		<fn> <ht> <rot> <mir> <x> <y>
	% Check for restricted text
	%
	rw 0 ne
	{

		%
		% Compute font scale factors
		%
		6 -2 roll pop		% <rot> <mir> <x> <y> <fn>
		rw mw div
		rht tc div dup ils mul 0.5 add cvi /tht exch def
		matrix scale makefont	% <rot> <mir> <x> <y> <fn>
		/mw rw def
	}
	{
		6 -2 roll		% <rot> <mir> <x> <y> <fn> <ht>
		dup 0 eq		% Test if height is 0
		{			% change to 1 if it is
                	1 exch pop	% <rot> <mir> <x> <y> <fn> <1>
		}
		if
		dup ils mul 0.5 add cvi /tht exch def
		dup mw mul /mw exch def scalefont
	}
	ifelse

	setfont				% <rot> <mir> <x> <y>

	moveto			% <rot> <mir>

	xformdict begin
		/savematrix xformmtrx currentmatrix def

		exch matrix rotate concat
		dup 1 eq
		{
			pop 1.0 -1.0		% x mirror
		}
		{
			2 eq
			{
				-1.0 1.0	% y mirror
			}
			{
				1.0 1.0		% no mirror
			}
			ifelse
		}
		ifelse
		matrix scale concat

		currentpoint

		%
		% Adjust origin for text alignment. For lc (4), cc (5), and uc
		% (6) move left by width / 2. For lr (7), cr (8), and ur (9)
		% move left by width. For cl (2), cc (5), and cr (8) move down
		% by height / 2. For ul (3), uc (6), and ur (9) move down by
		% height.
		%
		textalign 2 eq textalign 5 eq or textalign 8 eq or
		{
			tht tc mul 2 div sub
		} if
		textalign 3 eq textalign 6 eq or textalign 9 eq or
		{
			tht tc mul sub
		} if
		/oy exch def

		textalign 3 gt textalign 7 lt and
		{
			mw 2 div sub
		} if
		textalign 6 gt textalign 10 lt and
		{
			mw sub
		} if
		/ox exch def

		0 1 tc 1 sub
		{
			dup taln gt 1 index tasz mod 0 eq and
			{
				/cta cta tasz get def
			}
			if

			cta exch tasz mod get aload pop
			dup 3 -1 roll	% (str) [score] [score] <cnt>
			0 1 3 -1 roll 1 sub	% (str) [score] [score] 0 1 <cnt>
			{
				newpath ox oy moveto
				get aload pop pop exch	% ... <len> <start>
				dup 0 exch		% ... <len> <start> 0 <s
				5 index 3 1 roll	% ... (str) 0 <start>
				getinterval		% ... <len> <start> (.)
				stringwidth pop tht rmoveto
				3 index			% ... <len> <start> (str)
				3 1 roll exch		% ... (str) <start> <len>
%				dup 3 1 roll
%				sub
				getinterval stringwidth pop
				0 rlineto stroke
				dup
			}
			for
			pop pop
			ox oy moveto
			show

			%
			% Move origin for next line
			%
			/oy oy tht sub def
		}
		for

		savematrix setmatrix
	end
	pop					% throw away the "0"
} bind def
%*****************************
%
% End of Cadence eps.prologue
%
%*****************************
/setpacking where
{
	pop currpack setpacking
} if
%%EndProlog
/#copies 1 def
 563 72000 300 pap
%%Page: cds 1
gis
0 0 563 350 clwin
0 0 563 349 clwin
0 0 563 349 clwin
ssls
3 0 238 187 dls
0 -15 240 187 dls
3 0 238 172 dls
249 187 dlt
-2 -1 dlv
-1 -2 dlv
-1 -4 dlv
0 -2 dlv
1 -4 dlv
1 -2 dlv
2 0 dlv
2 0 dlv
2 0 dlv
1 2 dlv
1 4 dlv
0 2 dlv
-1 4 dlv
-1 2 dlv
-2 1 dlv
-2 0 dlv
dle
-10 -15 255 187 dls
0 56 218 18 dls
200 18 dpb
237 18 dpv
218 0 dpv
dpu
160 222 dlt
4 -6 dlv
8 0 dlv
3 6 dlv
dle
190 222 dlt
-3 6 dlv
-8 0 dlv
-4 -6 dlv
dle
0 -37 218 205 dls
0 -37 218 280 dls
0 -30 218 239 dls
218 239 dlt
8 -9 dlv
-15 0 dlv
7 9 dlv
dle
239 224 dpb
235 233 dpv
228 241 dpv
215 243 dpv
205 239 dpv
198 230 dpv
198 218 dpv
205 209 dpv
215 205 dpv
228 207 dpv
235 215 dpv
dpu
349 168 dlt
0 22 dlv
-18 6 dlv
37 11 dlv
-37 11 dlv
37 12 dlv
-37 11 dlv
37 11 dlv
-19 6 dlv
0 22 dlv
dle
75 0 349 280 dls
75 0 349 168 dls
0 60 424 168 dls
0 41 424 239 dls
0 38 424 130 dls
0 37 424 280 dls
443 220 dlt
-11 6 dlv
-15 2 dlv
-12 -8 dlv
dle
38 0 405 239 dls
75 0 424 280 dls
75 0 424 168 dls
0 26 499 254 dls
0 26 499 168 dls
4 0 499 209 dls
4 0 499 194 dls
4 0 499 224 dls
4 0 499 239 dls
4 0 499 254 dls
505 239 dlt
5 2 dlv
2 7 dlv
-4 4 dlv
-5 2 dlv
dle
505 194 dlt
5 2 dlv
2 7 dlv
-4 4 dlv
-5 2 dlv
dle
505 224 dlt
5 2 dlv
2 7 dlv
-4 4 dlv
-5 2 dlv
dle
505 209 dlt
5 2 dlv
2 7 dlv
-4 4 dlv
-5 2 dlv
dle
519 265 dpb
518 271 dpv
512 271 dpv
508 265 dpv
510 259 dpv
516 259 dpv
dpu
0 56 424 18 dls
405 18 dpb
443 18 dpv
424 0 dpv
dpu
0 94 218 74 dls
0 37 218 280 dls
206 0 218 317 dls
0 56 424 74 dls
303 331 dlt
8 18 dlv
7 -18 dlv
dle
9 0 306 337 dls
246 46 dlt
0 -10 dlv
0 -2 dlv
-1 -1 dlv
-1 0 dlv
-2 0 dlv
-1 0 dlv
dle
246 44 dlt
-1 1 dlv
-1 1 dlv
-2 0 dlv
-1 -1 dlv
-1 -1 dlv
-1 -2 dlv
0 -1 dlv
1 -2 dlv
1 -1 dlv
1 -1 dlv
2 0 dlv
1 1 dlv
1 1 dlv
dle
0 -9 251 46 dls
251 43 dlt
2 2 dlv
2 1 dlv
1 0 dlv
2 -1 dlv
0 -2 dlv
0 -6 dlv
dle
0 -13 270 50 dls
270 44 dlt
-1 1 dlv
-1 1 dlv
-2 0 dlv
-2 -1 dlv
-1 -1 dlv
0 -2 dlv
0 -1 dlv
0 -2 dlv
1 -1 dlv
2 -1 dlv
2 0 dlv
1 1 dlv
1 1 dlv
dle
13 0 380 301 dls
383 301 dlt
-2 -2 dlv
-1 -2 dlv
0 -2 dlv
1 -2 dlv
2 -2 dlv
3 -1 dlv
2 0 dlv
2 1 dlv
2 2 dlv
1 2 dlv
0 2 dlv
-1 2 dlv
-2 2 dlv
dle
19 0 377 145 dls
386 145 dlt
-2 2 dlv
0 2 dlv
0 2 dlv
0 2 dlv
2 2 dlv
3 1 dlv
2 0 dlv
2 -1 dlv
2 -2 dlv
1 -2 dlv
0 -2 dlv
-1 -2 dlv
-2 -2 dlv
dle
452 46 dlt
0 -10 dlv
0 -2 dlv
-1 -1 dlv
-1 0 dlv
-2 0 dlv
-1 0 dlv
dle
452 44 dlt
-1 1 dlv
-1 1 dlv
-2 0 dlv
-1 -1 dlv
-2 -1 dlv
0 -2 dlv
0 -1 dlv
0 -2 dlv
2 -1 dlv
1 -1 dlv
2 0 dlv
1 1 dlv
1 1 dlv
dle
0 -9 457 46 dls
457 43 dlt
2 2 dlv
1 1 dlv
2 0 dlv
1 -1 dlv
1 -2 dlv
0 -6 dlv
dle
0 -13 476 50 dls
476 44 dlt
-1 1 dlv
-2 1 dlv
-2 0 dlv
-1 -1 dlv
-1 -1 dlv
-1 -2 dlv
0 -1 dlv
1 -2 dlv
1 -1 dlv
1 -1 dlv
2 0 dlv
2 1 dlv
1 1 dlv
dle
211 67 226 82 dbs
211 160 226 175 dbs
211 273 226 288 dbs
417 123 432 138 dbs
417 310 432 325 dbs
417 67 432 82 dbs
0 0 563 351 clwin
gfs
%%Trailer
%%EOF
